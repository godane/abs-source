--- src/anki-0.9.9.8.6/libanki/anki/deck.py	2010-02-12 20:00:52.000000000 +1100
+++ tmp/deck.py	2010-04-21 14:35:56.347044304 +1000
@@ -373,6 +373,7 @@
         space = space * spaceFactor * 86400.0
         space = max(minSpacing, space)
         space += time.time()
+        card.combinedDue = max(card.due, space)
         # check what other cards we've spaced
         if self.reviewEarly:
             extra = ""
@@ -681,7 +682,6 @@
         self._dailyStats = dailyStats(self)
         # mark due cards and update counts
         self.checkDue()
-        # invalid card count
         # determine new card distribution
         if self.newCardSpacing == NEW_CARDS_DISTRIBUTE:
             if self.newCountToday:
@@ -1065,13 +1065,13 @@
             due = random.uniform(0, time.time())
         t = time.time()
         for cardModel in cms:
-            card = anki.cards.Card(fact, cardModel, t)
+            created = fact.created + 0.000001*cardModel.ordinal
+            card = anki.cards.Card(fact, cardModel, created)
             if isRandom:
-                card.due = due + card.ordinal
-                card.combinedDue = card.due
+                card.due = due
+                card.combinedDue = due
             self.flushMod()
             cards.append(card)
-            t += .00001
         self.updateFactTags([fact.id])
         self.updatePriorities([c.id for c in cards])
         self.cardCount += len(cards)
@@ -1116,8 +1116,9 @@
 select count(id) from cards
 where factId = :fid and cardModelId = :cmid""",
                                  fid=fact.id, cmid=cardModel.id) == 0:
+                    # enough for 10 card models assuming 0.00001 timer precision
                     card = anki.cards.Card(
-                        fact, cardModel, created=fact.created+cardModel.ordinal)
+                        fact, cardModel, created=fact.created+0.000001*cardModel.ordinal)
                     self.updateCardTags([card.id])
                     self.updatePriority(card)
                     self.cardCount += 1
@@ -1957,6 +1958,7 @@
                 elif isNeg:
                     fquery += "select id from facts except "
                 token = token.replace("*", "%")
+                token = token.replace("?", "_")
                 args["_ff_%d" % c] = "%"+token+"%"
                 q = "select factId from fields where value like :_ff_%d" % c
                 fquery += q
@@ -2273,7 +2275,7 @@
             pass
         self.startProgress()
         # copy tables, avoiding implicit commit on current db
-        DeckStorage.Deck(newPath).close()
+        DeckStorage.Deck(newPath, backup=False).close()
         new = sqlite.connect(newPath)
         for table in self.s.column0(
             "select name from sqlite_master where type = 'table'"):
@@ -2297,7 +2299,7 @@
         new.close()
         self.close()
         # open again in orm
-        newDeck = DeckStorage.Deck(newPath)
+        newDeck = DeckStorage.Deck(newPath, backup=False)
         # move media
         if oldMediaDir:
             newDeck.renameMediaDir(oldMediaDir)
@@ -2839,7 +2841,10 @@
     def _init(s):
         "Add a new deck to the database. Return saved deck."
         deck = Deck()
-        s.save(deck)
+        if sqlalchemy.__version__.startswith("0.4."):
+            s.save(deck)
+        else:
+            s.add(deck)
         s.flush()
         return deck
     _init = staticmethod(_init)
@@ -3353,6 +3358,11 @@
             path = path.replace(":", "")
             return path
         escp = escape(path)
+        # make sure backup dir exists
+        try:
+            os.makedirs(backupDir)
+        except (OSError, IOError):
+            pass
         # find existing backups
         gen = re.sub("\.anki$", ".backup-(\d+).anki", re.escape(escp))
         backups = []
